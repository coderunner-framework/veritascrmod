require 'coderunner'

class CodeRunner
  #  This is a customised subclass of the CodeRunner::Run  class which allows CodeRunner to run and analyse the Vlasov Maxwell solver Veritas.
  #
  #  It  generates the Veritas input file, and both analyses the results and allows easy plotting of them. 
  class Veritas < Run::FortranNamelist

    # Where this file is
    @code_module_folder = File.dirname(File.expand_path(__FILE__)) # i.e. the directory this file is in

    # Use the Run::FortranNamelist tools to process the variable database
    setup_namelists(@code_module_folder)


    ################################################
    # Quantities that are read or determined by CodeRunner
    # after the simulation has ended
    ###################################################

    @results = [
    ]

    @code_long="Veritas Vlasov-Maxwell Solver"

    @run_info=[:time, :is_a_restart, :restart_id, :percent_complete]

    @uses_mpi = true

    @modlet_required = false

    @naming_pars = []

    #  Any folders which are a number will contain the results from flux simulations.
    @excluded_sub_folders = ['output']

    #  A hook which gets called when printing the standard run information to the screen using the status command.
    def print_out_line
      #p ['id', id, 'ctd', ctd]
      #p rcp.results.zip(rcp.results.map{|r| send(r)})
      name = @run_name
      name += " (res: #@restart_id)" if @restart_id
      name += " real_id: #@real_id" if @real_id
      beginning = sprintf("%2d:%d %-60s %1s:%2.1f(%s) %3s%1s",  @id, @job_no, name, @status.to_s[0,1],  @run_time.to_f / 60.0, @nprocs.to_s, percent_complete.to_f, "%")
      #if ctd and fusionQ
        #beginning += sprintf("Q:%f, Pfusion:%f MW, Ti0:%f keV, Te0:%f keV, n0:%f x10^20", fusionQ, pfus, ti0, te0, ne0)
      #end
      #beginning += "  ---#{@comment}" if @comment
      beginning
    end

    #def self.load(dir, runner)
      #run = super(dir, runner)
      #grun_list = run.instance_variable_get(:@gs2_run_list)
      #grun_list.values.each{|r| r.runner=runner} if grun_list.kind_of? Hash
      #run
    #end


    # Modify new_run so that it becomes a restart of self. Adusts
    # all the parameters of the new run to be equal to the parameters
    # of the run that calls this function, and sets up its run name
    # correctly
    def restart(new_run)
      (rcp.variables).each{|v| new_run.set(v, send(v)) if send(v) or new_run.send(v)}
      raise "restart not implemented yet"
    end
    #  This is a hook which gets called just before submitting a simulation. It sets up the folder and generates any necessary input files.
    def generate_input_file
        FileUtils.makedirs("output/rectangleData")
        #@run_name += "_t"
        if @restart_id
          @runner.run_list[@restart_id].restart(self)
        end
        #if uses_ecom?
          #setup_ecom
        #elsif uses_chease?
          #setup_chease
        #end
        #check_parameters
        write_input_file
    end






    def vim_output
      system "vim -Ro #{output_file} #{error_file}"
    end
    alias :vo :vim_output

    #  This command uses the infrastructure provided by Run::FortranNamelist, provided by CodeRunner itself.
    def write_input_file
      File.open(@run_name + ".in", 'w'){|file| file.puts input_file_text}
    end

    # Parameters which follow the Veritas executable, in this case just the input file.
    def parameter_string
      @run_name + ".in"
    end

    def parameter_transition
    end



    @source_code_subfolders = []

    # This method, as its name suggests, is called whenever CodeRunner is asked to analyse a run directory. This happens if the run status is not :Complete, or if the user has specified recalc_all(-A on the command line) or reprocess_all (-a on the command line).
    #
    def process_directory_code_specific
      get_status
    end

    def get_status
      if @running
        @status = :Running
      else
        @status = :Complete
      end
    end



    def input_file_header
      <<EOF
!==============================================================================
!     Veritas INPUT FILE automatically generated by CodeRunner
!==============================================================================
!
!  Veritas is a 1D continuum solver for the Vlasov-Maxwell system
!
!   See http://ft.nephy.chalmers.se/veritas/
!
!  CodeRunner is a framework for the automated running and analysis
!  of large simulations.
!
!   See http://coderunner.sourceforge.net
!
!  Created #{Time.now.to_s}
!      by CodeRunner version #{CodeRunner::CODE_RUNNER_VERSION.to_s}
!
!==============================================================================

EOF
    end
    def self.defaults_file_header
      <<EOF1
############################################################################
#                                                                          #
# Automatically generated defaults file for the Veritas CodeRunner module  #
#                                                                          #
# This defaults file specifies a set of defaults for Veritas which are     #
# used by CodeRunner to set up and run Veritas simulations.                #
#                                                                          #
############################################################################

# Created: #{Time.now.to_s}

@defaults_file_description = ""
EOF1
    end


    def input_file_extension
      '.in'
    end

 # Override CodeRunner for 0-based# Override CodeRunner for 0-based# Override CodeRunner for 0-based  
def input_file_text
	text = input_file_header
	rcp.namelists.each do |namelist, hash|
		next if hash[:should_include].kind_of? String and not eval(hash[:should_include])
		if en = hash[:enumerator] # Single = is deliberate!
			next unless send(en[:name])
			send(en[:name]).times do |i|
				next unless hash[:variables].keys.inject(false){|b, v| b or !send(v+"_#{i+0}".to_sym).nil?} # i.e. at least one variable must be non-nil 
				text << namelist_text(namelist, i+0)
			end
		else
			next unless hash[:variables].keys.inject(false){|b, v| b or !send(v).nil?} # i.e. at least one variable must be non-nil 
			text << namelist_text(namelist)
		end
			
			
	end
	text
end
def namelist_text(namelist, enum = nil)
	hash = rcp.namelists[namelist]
	text = ""
	ext = enum ? "_#{enum}" : ""
	text << "!#{'='*30}\n!#{hash[:description]} #{enum} \n!#{'='*30}\n" if hash[:description]
	text << "&#{namelist}#{ext}\n"
	hash[:variables].each do |var, var_hash|
		code_var = (var_hash[:code_name] or var)
		cr_var = var+ext.to_sym 
		value = send(cr_var)
		if send(cr_var) and (not var_hash[:should_include] or  eval(var_hash[:should_include]))
			if value.kind_of? Array
				value.each_with_index do |v, i|
					output = formatted_variable_output(v)
					text << " #{code_var}(#{i+0}) = #{output} #{var_hash[:description] ? "! #{var_hash[:description]}": ""}\n"
				end
			else
				output = formatted_variable_output(value)
				text << " #{code_var} = #{output} #{var_hash[:description] ? "! #{var_hash[:description]}": ""}\n"
			end
		elsif rcp.namelists_to_print_not_specified? and rcp.namelists_to_print_not_specified.include?(namelist) 
			text << "  ! #{code_var} not specified --- #{var_hash[:description]}\n"
		end
	end
	text << "/\n\n"
	text
end
	@variables = @namelists.inject([]) do |arr, (namelist, namelist_hash)|
		if en = namelist_hash[:enumerator]
			en[:estimated_value].times do |i|
				namelist_hash[:variables].each{|var, var_hash| arr.push var + "_#{i+0}".to_sym}
			end
		else
			namelist_hash[:variables].each{|var, var_hash| arr.push var}
		end
		arr
	end
def self.defaults_file_text_from_input_file(input_file)
	string = defaults_file_header

	hash = parse_input_file(input_file)
	#pp hash; exit
	#ep ['class', self.to_s, 'namelists', rcp.namelists.keys, 'code_long', rcp.code_long, 'namelist_hashes', rcp.namelists.values.map{|v| v.class}]
	rcp.namelists.each do |namelist, namelist_hash|
 		#ep namelist
		if namelist_hash[:enumerator]  # ie. This is an indexed namelist
      #p namelist_hash[:enumerator]
			enumerator = namelist_hash[:enumerator][:name]
			enum_hash = hash.find{|nml, nmlh| nmlh[enumerator]}
			next unless enum_hash
			#pp enum_hash
			enum = enum_hash[1][enumerator]
			enum.times{|i| string << namelist_defaults_text(hash, namelist, namelist_hash, i+0)}
		else
			string << namelist_defaults_text(hash, namelist, namelist_hash)
		end
	end
	string
end
  end
end

