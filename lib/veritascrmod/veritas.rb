require 'coderunner'

class CodeRunner
  #  This is a customised subclass of the CodeRunner::Run  class which allows CodeRunner to run and analyse the Vlasov Maxwell solver Veritas.
  #
  #  It  generates the Veritas input file, and both analyses the results and allows easy plotting of them. 
  class Veritas < Run::FortranNamelist

    # Where this file is
    @code_module_folder = File.dirname(File.expand_path(__FILE__)) # i.e. the directory this file is in

    require 'veritascrmod/read_netcdf.rb'

    # Use the Run::FortranNamelist tools to process the variable database
    setup_namelists(@code_module_folder)


    ################################################
    # Quantities that are read or determined by CodeRunner
    # after the simulation has ended
    ###################################################

    @results = [
    ]

    @code_long="Veritas Vlasov-Maxwell Solver"

    @run_info=[:time, :is_a_restart, :restart_id, :percent_complete]

    @uses_mpi = true

    @modlet_required = false

    @naming_pars = []

    #  Any folders which are a number will contain the results from flux simulations.
    @excluded_sub_folders = ['output']

    #  A hook which gets called when printing the standard run information to the screen using the status command.
    def print_out_line
      #p ['id', id, 'ctd', ctd]
      #p rcp.results.zip(rcp.results.map{|r| send(r)})
      name = @run_name
      name += " (res: #@restart_id)" if @restart_id
      name += " real_id: #@real_id" if @real_id
      beginning = sprintf("%2d:%d %-60s %1s:%2.1f(%s) %3s%1s",  @id, @job_no, name, @status.to_s[0,1],  @run_time.to_f / 60.0, @nprocs.to_s, percent_complete.to_f, "%")
      beginning += " n:#@nlines " if @nlines
      #if ctd and fusionQ
        #beginning += sprintf("Q:%f, Pfusion:%f MW, Ti0:%f keV, Te0:%f keV, n0:%f x10^20", fusionQ, pfus, ti0, te0, ne0)
      #end
      #beginning += "  ---#{@comment}" if @comment
      beginning
    end

    #def self.load(dir, runner)
      #run = super(dir, runner)
      #grun_list = run.instance_variable_get(:@gs2_run_list)
      #grun_list.values.each{|r| r.runner=runner} if grun_list.kind_of? Hash
      #run
    #end


    # Modify new_run so that it becomes a restart of self. Adusts
    # all the parameters of the new run to be equal to the parameters
    # of the run that calls this function, and sets up its run name
    # correctly
    def restart(new_run)
      (rcp.variables).each{|v| new_run.set(v, send(v)) if send(v) or new_run.send(v)}
      raise "restart not implemented yet"
    end
    #  This is a hook which gets called just before submitting a simulation. It sets up the folder and generates any necessary input files.
    def generate_input_file
        FileUtils.makedirs("output/rectangleData")
        #@run_name += "_t"
        if @restart_id
          @runner.run_list[@restart_id].restart(self)
        end
        #if uses_ecom?
          #setup_ecom
        #elsif uses_chease?
          #setup_chease
        #end
        #check_parameters
        write_input_file
    end






    def vim_output
      system "vim -Ro #{output_file} #{error_file}"
    end
    alias :vo :vim_output

    #  This command uses the infrastructure provided by Run::FortranNamelist, provided by CodeRunner itself.
    def write_input_file
      File.open(@run_name + ".in", 'w'){|file| file.puts input_file_text}
    end

    # Parameters which follow the Veritas executable, in this case just the input file.
    def parameter_string
      @run_name + ".in"
    end

    def parameter_transition
    end



    @source_code_subfolders = []

    # This method, as its name suggests, is called whenever CodeRunner is asked to analyse a run directory. This happens if the run status is not :Complete, or if the user has specified recalc_all(-A on the command line) or reprocess_all (-a on the command line).
    #
    def process_directory_code_specific
      get_status
      if FileTest.exist? 'output/time.txt'
        @nlines = File.read('output/time.txt').split("\n").size
      end

    end

    def get_status
      if @running
        @status = :Running
      else
        @status = :Complete
      end
    end



    def input_file_header
      <<EOF
!==============================================================================
!     Veritas INPUT FILE automatically generated by CodeRunner
!==============================================================================
!
!  Veritas is a 1D continuum solver for the Vlasov-Maxwell system
!
!   See http://ft.nephy.chalmers.se/veritas/
!
!  CodeRunner is a framework for the automated running and analysis
!  of large simulations.
!
!   See http://coderunner.sourceforge.net
!
!  Created #{Time.now.to_s}
!      by CodeRunner version #{CodeRunner::CODE_RUNNER_VERSION.to_s}
!
!==============================================================================

EOF
    end
    def self.defaults_file_header
      <<EOF1
############################################################################
#                                                                          #
# Automatically generated defaults file for the Veritas CodeRunner module  #
#                                                                          #
# This defaults file specifies a set of defaults for Veritas which are     #
# used by CodeRunner to set up and run Veritas simulations.                #
#                                                                          #
############################################################################

# Created: #{Time.now.to_s}

@defaults_file_description = ""
EOF1
    end


    def input_file_extension
      '.in'
    end

  def self.modify_job_script(runner, runs_in, script)
    if CODE_OPTIONS[:veritas] and CODE_OPTIONS[:veritas][:list]
      if (list_size = CODE_OPTIONS[:veritas][:list]).kind_of? Integer
        raise "The total number of runs must be a multiple of the list size!" unless runs_in.size % list_size == 0
        pieces = runs_in.pieces(runs_in.size/list_size)
      else
        pieces = [runs_in]
      end
      script = ""
      pieces.each do |runs|
        #ep 'there is a list'
        FileUtils.makedirs('job_lists')
        jid = "#{runs[0].id}-#{runs[-1].id}"
        list_file = "../job_lists/veritas_list_#{jid}.list"
        Dir.chdir('job_chain_files') do
          File.open(list_file,'w') do |file|
            file.puts runs.size
            file.puts runs.map{|r| "../#{r.relative_directory}/\n#{r.run_name}"}.join("\n")
          end
        end
        raise "runs must all have the same nprocs" unless runs.map{|r| r.nprocs}.uniq.size == 1
        runs.each do |r|
          # Make sure the restart file name includes the relative directory for
          # list runs
          #reldir = r.relative_directory
          #puts rdir[0...reldir.size] == reldir, rdir[0...reldir.size], reldir
          #raise ""
          Dir.chdir(r.directory){r.write_input_file}
        end
        #np = runs[0].nprocs.split('x').map{|n| n.to_i}
        #np[0] *= runs.size
        #nprocs = np.map{|n| n.to_s}.join('x')
        #@runner.nprocs = nprocs
        @runner.nprocs = runs[0].nprocs
        ls = ListSubmitter.new(@runner, @runner.nprocs, list_file, jid)
        script <<  'cd job_chain_files; '
        script << ls.run_command
      end
    end
    return script
  end

  class ListSubmitter
    include CodeRunner::SYSTEM_MODULE
    @uses_mpi = true
    attr_reader :executable_location, :executable_name, :parameter_string
    attr_reader :job_identifier
    def initialize(runner, nprocs, list_file, jid)
      @executable_location = runner.executable_location
      @executable_name = runner.executable_name
      @parameter_string = list_file
      @job_identifier = jid
      @nprocs = nprocs
    end
    def rcp
      self.class.rcp
    end
    def self.rcp
      @rcp ||= CodeRunner::Run::RunClassPropertyFetcher.new(self)
    end

  end #class ListSubmitter
def graphkit(name, options)
  if name =~ /^nc/
    smart_graphkit(options.absorb(graphkit_name: name))
  else
    send((name + '_graphkit').to_sym, options)
  end
end
def potential_graphkit(options)
  real_space_graphkit(signal: 'phi')
end
def asquared_graphkit(options)
  real_space_graphkit(signal: 'asquared')
end
def asquared2d_graphkit(options)
  real_space_2d_graphkit(options.dup.absorb(signal: 'asquared'))
end
def openncfile
  require 'numru/netcdf'
  res = nil
  file = NumRu::NetCDF.open("#@directory/#@run_name.nc")
  res = yield(file)
  file.close
  res
end
def real_space_graphkit(options)
  Dir.chdir(@directory) do
    mat = openncfile{|f| f.var(options[:signal]).get} 
    shape = mat.shape
    p 'shape', mat.shape
    x = shape[0].times.to_a
    t = shape[1].times.to_a
    kit = GraphKit.quick_create([x, t, mat])
    kit.gp.view = "map"
    kit.gp.palette = "rgb 23,28,3"
    kit.data[0].gp.with = "pm3d"
    kit
  end
end
def real_space_2d_graphkit(options)
  t = options[:t]
  raise "Please supply :t" unless t
  Dir.chdir(@directory) do
    vec = openncfile{|f| f.var(options[:signal]).get('start'=>[0,t], 'end'=>[-1,t])} 
    mat = GSL::Matrix.alloc(vec.size, 2)
    for i in 0...vec.size
      mat[i,0] = mat[i,1] = vec[i]
    end
    shape = mat.shape
    p 'shape', mat.shape
    x = shape[0].times.to_a
    t = shape[1].times.to_a
    kit = GraphKit.quick_create([x, t, mat])
    kit.gp.view = "map"
    kit.gp.palette = "rgb 23,28,3"
    kit.data[0].gp.with = "pm3d"
    kit
  end
end
def waveandparticles_graphkit(options)
  kit = GraphKit::MultiKit.new([
    asquared2d_graphkit(options),
    dist_fn_graphkit(options)
  ])
  kit[0].gp.size = "1.0,0.3"
  kit[0].gp.origin = "0.0,0.7"
  kit[1].gp.size = "1.0,0.9"
  kit[1].gp.origin = "0.0,-0.1"
  kit[1].gp.cbrange = "[0:]"
  kit.each do |k|
    k.key="off"
    k.xlabel=nil
    k.ylabel=nil
    k.gp.xtics = "unset"
    k.gp.ytics = "unset"
    k.title = nil
  end
  kit
end
def vspace_dist_fn_graphkit(options)
  kit = dist_fn_graphkit(options)
  mat = kit.data[0].z.data
  pvec = GSL::Vector.alloc(mat.shape[1])
  pvec = 0.0
  for i in 0...mat.shape[0]
    pvec = pvec + mat.row(i)
  end
  kit2 = GraphKit.quick_create([kit.data[0].y.data, pvec])
  kit2.data[0].gp.with = "lp"
  kit2.gp.logscale = "y"
  kit2
end
def dist_fn_graphkit(options)
  t = options[:t]
  p = options[:particle]
  raise "Please supply :t" unless t
  raise "Please supply :particle" unless p
  mat = openncfile do |f| 
    m = GSL::Matrix.alloc(f.dim("x_finest").length, f.dim("p_finest").length)
    nlevels = f.dim("level").length
    nlevels.times.to_a.reverse.each do |l|
    #[2].each do |l|
      factor = (@r||2)**l 
      # NB the Ruby netCDF interface is (very annoyingly) written in column major (Fortran) style
      nrectangles = f.var("level_rnum").get('index'=> [l,p,t])[0]
      nrectangles.times do |r|
        urid = f.var('urid').get('index'=>[r,l,p,t])[0]
        md = f.var('rectangle_metadata').get('start'=>[0,0,urid], 'end'=>[-1,-1,urid])[true,true,0]
        x_indices = f.var("integer_blob_data").get('start'=>[md[0,0]], 'end'=>[md[1,0]])
        p_indices = f.var("integer_blob_data").get('start'=>[md[0,1]], 'end'=>[md[1,1]])
        fdata = f.var("double_blob_data").get('start'=>[md[0,2]], 'end'=>[md[1,2]])
        p_size = md[1,1] - md[0,1] + 1
        x_indices.to_a.each_with_index do |ixglobal,ixrec|
          p_indices.to_a.each_with_index do |ipglobal,iprec|
            index = ixrec*p_size + iprec
            #ep ["index", index, "fsize", md[1,2]-md[0,2]+1, 'ix', ixrec, 'ip', iprec, 'p_size', p_size, 'level', l, 'ixglobal', ixglobal, 'factor', factor]
            for i in 0...factor
              for j in 0...factor
                m[ixglobal*factor+i,ipglobal*factor+j] = fdata[index]
              end 
            end
          end
        end
      end
    end
    m
  end
  #mat = mat.log if (options[:log])
  shape = mat.shape
  p 'shape', mat.shape
  x = shape[0].times.to_a.reverse
  t = shape[1].times.to_a.reverse
  kit = GraphKit.quick_create([x, t, mat])
  #kit.live = true
  kit.gp.view = "map"
  kit.gp.palette = "rgb 23,28,3"
  kit.data[0].gp.with = "pm3d"
  kit
end
 # Override CodeRunner for 0-based# Override CodeRunner for 0-based# Override CodeRunner for 0-based  
def input_file_text
	text = input_file_header
	rcp.namelists.each do |namelist, hash|
		next if hash[:should_include].kind_of? String and not eval(hash[:should_include])
		if en = hash[:enumerator] # Single = is deliberate!
			next unless send(en[:name])
			send(en[:name]).times do |i|
				next unless hash[:variables].keys.inject(false){|b, v| b or !send(v+"_#{i+0}".to_sym).nil?} # i.e. at least one variable must be non-nil 
				text << namelist_text(namelist, i+0)
			end
		else
			next unless hash[:variables].keys.inject(false){|b, v| b or !send(v).nil?} # i.e. at least one variable must be non-nil 
			text << namelist_text(namelist)
		end
			
			
	end
	text
end
def namelist_text(namelist, enum = nil)
	hash = rcp.namelists[namelist]
	text = ""
	ext = enum ? "_#{enum}" : ""
	text << "!#{'='*30}\n!#{hash[:description]} #{enum} \n!#{'='*30}\n" if hash[:description]
	text << "&#{namelist}#{ext}\n"
	hash[:variables].each do |var, var_hash|
		code_var = (var_hash[:code_name] or var)
		cr_var = var+ext.to_sym 
		value = send(cr_var)
		if send(cr_var) and (not var_hash[:should_include] or  eval(var_hash[:should_include]))
			if value.kind_of? Array
				value.each_with_index do |v, i|
					output = formatted_variable_output(v)
					text << " #{code_var}(#{i+0}) = #{output} #{var_hash[:description] ? "! #{var_hash[:description]}": ""}\n"
				end
			else
				output = formatted_variable_output(value)
				text << " #{code_var} = #{output} #{var_hash[:description] ? "! #{var_hash[:description]}": ""}\n"
			end
		elsif rcp.namelists_to_print_not_specified? and rcp.namelists_to_print_not_specified.include?(namelist) 
			text << "  ! #{code_var} not specified --- #{var_hash[:description]}\n"
		end
	end
	text << "/\n\n"
	text
end
	@variables = @namelists.inject([]) do |arr, (namelist, namelist_hash)|
		if en = namelist_hash[:enumerator]
			en[:estimated_value].times do |i|
				namelist_hash[:variables].each{|var, var_hash| arr.push var + "_#{i+0}".to_sym}
			end
		else
			namelist_hash[:variables].each{|var, var_hash| arr.push var}
		end
		arr
	end
def self.defaults_file_text_from_input_file(input_file)
	string = defaults_file_header

	hash = parse_input_file(input_file)
	#pp hash; exit
	#ep ['class', self.to_s, 'namelists', rcp.namelists.keys, 'code_long', rcp.code_long, 'namelist_hashes', rcp.namelists.values.map{|v| v.class}]
	rcp.namelists.each do |namelist, namelist_hash|
 		#ep namelist
		if namelist_hash[:enumerator]  # ie. This is an indexed namelist
      #p namelist_hash[:enumerator]
			enumerator = namelist_hash[:enumerator][:name]
			enum_hash = hash.find{|nml, nmlh| nmlh[enumerator]}
			next unless enum_hash
			#pp enum_hash
			enum = enum_hash[1][enumerator]
			enum.times{|i| string << namelist_defaults_text(hash, namelist, namelist_hash, i+0)}
		else
			string << namelist_defaults_text(hash, namelist, namelist_hash)
		end
	end
	string
end
  end
end

